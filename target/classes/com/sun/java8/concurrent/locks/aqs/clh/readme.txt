自旋锁、排队自旋锁、MCS锁、CLH锁

自旋锁本身多用于线程之间的同步。如果2个线程之间的竞争不是非常激烈，比如A线程获取锁，此时B试图获取锁，
处理器阻塞一个线程引起的上下文的切换代价高于等待资源的时候，B可以不放弃CPU时间片，而是在原地等待，
直到锁的持有者释放，这就是自旋锁的意义。

自旋锁:指当一个线程尝试获取某个锁时，如果该锁已经被其他线程占用，就一直循环检测锁是否被释放，而不是进入挂起或者睡眠。
      适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间很短。
参考：SpinLock
缺点:
    1.CAS操作需要硬件配合；
    2.保证各个CPU的缓存（L1,L2,L3，跨cpu socket，主存）的数据一致性通讯开销很大，很多处理器上更严重；
    3.没法保证公平性，不保证等待进程/线程按照FIFO顺序获得锁

Ticket Lock：为了解决上述的公平性问题，锁拥有一个服务号，表示正在服务的线程；还有一个排队号。
            每个线程尝试获取锁之前先拿一个排队号，然后不断轮询锁的当前服务号是否是自己的排队号，
            如果是则表示自己拥有了锁，否则继续。
            当线程释放锁时讲服务号+1，这样下一个线程看到这个变化就退出自旋。
参考：TickLock
缺点：虽然解决了公平性的问题，但是在多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum
     每次读写操作都必须在多个处理器缓存之间进行缓存同步，会导致繁重的系统总线和内存的流量，降低系统的性能。

CLH锁：基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，
        如果发现前驱释放了锁就结束自旋。



